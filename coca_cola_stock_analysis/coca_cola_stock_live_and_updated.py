# -*- coding: utf-8 -*-
"""Coca Cola Stock - Live and Updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nwSwv0UK_ypZ-lxbCAsmmGKvgFpW282v
"""

# Use Yahoo Finance API for historical data. We'll fetch data from 2015 to the present.
import yfinance as yf
import pandas as pd

# Fetch Coca-Cola stock data
ticker = 'KO' # Coca-Cola stock ticker
data = yf.download(ticker, start='2015-01-01',
end='2023-12-31')

# Reset index for easier handling
data.reset_index(inplace=True)

# Display data structure
print(data.info())
print(data.head())

# Check for missing values
print(data.isnull().sum())

# Fill missing numerical values with the column mean
data.fillna(method='ffill', inplace=True) # Forward fill for stock data continuity
data.fillna(0, inplace=True) # Replace remaining missing dividends/splits with 0

# Confirm no missing values remain
print(data.isnull().sum())

# Add Moving Averages
data['MA_20'] = data['Close'].rolling(window=20).mean()
data['MA_50'] = data['Close'].rolling(window=50).mean()

# Add Daily Returns
data['Daily_Return'] = data['Close'].pct_change()

# Add Volatility (standard deviation of returns over a rolling window)
data['Volatility'] = data['Daily_Return'].rolling(window=20).std()

# Drop rows with NA due to rolling calculations
data.dropna(inplace=True)

print(data.head())

# Summary statistics
print(data.describe())

import matplotlib.pyplot as plt
import seaborn as sns

# Line plot for stock prices
plt.figure(figsize=(12, 6))
plt.plot(data['Date'], data['Close'], label='Close Price')
plt.plot(data['Date'], data['MA_20'], label='MA 20',
linestyle='--')
plt.plot(data['Date'], data['MA_50'], label='MA 50',
linestyle='--')
plt.title('Coca-Cola Stock Prices with Moving Averages')
plt.xlabel('Date')

plt.ylabel('Price')
plt.legend()
plt.show()

# Correlation heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(data.corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Heatmap')
plt.show()

from sklearn.model_selection import train_test_split

# Select only existing columns
features = ['Open', 'High', 'Low', 'Volume', 'Dividends',
            'Stock Splits', 'MA_20', 'MA_50', 'Daily_Return', 'Volatility']
target = 'Close'

# Filter features to avoid KeyError
features = [col for col in features if col in data.columns]

# Check if target column exists
if target not in data.columns:
    raise KeyError(f"Target column '{target}' not found in dataset!")

# Prepare data
X = data[features]
y = data[target]

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, shuffle=False
)

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Initialize the model
model = RandomForestRegressor(n_estimators=100,
random_state=42)

# Train the model
model.fit(X_train, y_train)

# Predict on test set
y_pred = model.predict(X_test)

# Evaluate model
mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"Mean Absolute Error: {mae}")

# Fetch latest stock data
live_data = yf.download(ticker, period='1d', interval='1m')

# Prepare live data for prediction
live_data['MA_20'] = live_data['Close'].rolling(window=20).mean()
live_data['MA_50'] = live_data['Close'].rolling(window=50).mean()

live_data['Daily_Return'] = live_data['Close'].pct_change()
live_data['Volatility'] = live_data['Daily_Return'].rolling(window=20).std()

# Ensure no missing values
live_data.fillna(0, inplace=True)

# Use the latest data point for prediction
latest_features = live_data[features].iloc[-1:].dropna()
live_prediction = model.predict(latest_features)

print(f"Predicted Closing Price: {live_prediction[0]}")

import matplotlib.pyplot as plt

plt.figure(figsize=(10,5))
plt.plot(data['Close'], label='Close')
plt.plot(data['MA_20'], label='MA_20')
plt.plot(data['MA_50'], label='MA_50')
plt.title('Coca-Cola Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

print(f"Predicted Closing Price: {live_prediction[0]}")

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('whitegrid')
plt.style.use("fivethirtyeight")
# %matplotlib inline

# For reading stock data from yahoo
from pandas_datareader.data import DataReader

# For time stamps
from datetime import datetime
from math import sqrt
from math import sqrt

from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler

#ignore the warnings
import warnings
warnings.filterwarnings('ignore')

# Loading Dataset
KO_Data = pd.read_csv('/content/Coca-Cola_stock_history (2).csv')

KO_Data.plot(subplots = True, figsize = (10,12))
plt.title('Coca Cola Stock Attributes')
plt.show()

def plot_close_val(data_frame, column, stock):
  plt.figure(figsize=(16,6))

  plt.title(column + ' Price History for ' + stock )
  plt.plot(data_frame[column])
  plt.xlabel('Date', fontsize=18)
  plt.ylabel(column + ' Price USD ($) for ' + stock,fontsize=18)
  plt.show()

#Test the function
plot_close_val(KO_Data, 'Close', 'Coca Cola')
plot_close_val(KO_Data, 'Open', 'Coca Cola')

KO_Data[["Volume"]].plot()

import pandas as pd

# Load basic company info CSV
ko_info = pd.read_csv(
    '/content/Coca-Cola_stock_info (2).csv',
    header=None,
    names=['Description', 'Information']
)

# Clean data
ko_info.dropna(inplace=True)
ko_info = ko_info[ko_info['Information'] != 'nan']

# Sort by 'Information' column
ko = ko_info.sort_values('Information')

# Display nicely
ko.style.set_properties(**{'text-align': 'left'})

adj_close_px = KO_Data['Close']

# Calculate the moving average
moving_avg = adj_close_px.rolling(window=40).mean()

# Inspect the result
moving_avg[-10:]

# Short moving window rolling mean
KO_Data['42'] = adj_close_px.rolling(window=40).mean()

# Long moving window rolling mean
KO_Data['252'] = adj_close_px.rolling(window=252).mean()

# Plot the adjusted closing price, the short and long windows of rolling means
KO_Data[['Close', '42', '252']].plot()

plt.show()

daily_close_px = KO_Data[['Close']]
# Calculate the daily percentage change for `daily_close_px`
daily_pct_change = daily_close_px.pct_change()

# Plot the distributions
daily_pct_change.hist(bins=50, sharex=True, figsize=(12,8))

# Show the resulting plot
plt.show()

# Define the minumum of periods to consider
min_periods = 75

# Calculate the volatility
vol = daily_pct_change.rolling(min_periods).std() * np.sqrt(min_periods)

# Plot the volatility
vol.plot(figsize=(10, 8))

# Show the plot
plt.show()

# Plot a scatter matrix with the `daily_pct_change` data
pd.plotting.scatter_matrix(daily_pct_change, diagonal='kde',
alpha=0.1,figsize=(12,12))

# Show the plot
plt.show()

import plotly.graph_objects as go

KO_Data=KO_Data.reset_index()

fig = go.Figure(data=go.Ohlc(x=KO_Data['Date'],

open=KO_Data['Open'],
high=KO_Data['High'],
low=KO_Data['Low'],
close=KO_Data['Close']))

fig.show()

#KO_Data=KO_Data.reset_index()

KO_Data['SMA5'] = KO_Data.Close.rolling(5).mean()
KO_Data['SMA20'] = KO_Data.Close.rolling(20).mean()
KO_Data['SMA50'] = KO_Data.Close.rolling(50).mean()
KO_Data['SMA200'] = KO_Data.Close.rolling(200).mean()
KO_Data['SMA500'] = KO_Data.Close.rolling(500).mean()

fig = go.Figure(data=[go.Ohlc(x=KO_Data['Date'],open=KO_Data['Open'],
high=KO_Data['High'],low=KO_Data['Low'],close=KO_Data['Close'],
name = "OHLC"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA5, line=dict(color='orange', width=1),
name="SMA5"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA20, line=dict(color='green', width=1),
name="SMA20"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA50, line=dict(color='blue', width=1),
name="SMA50"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA200, line=dict(color='violet', width=1),
name="SMA200"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA500, line=dict(color='purple', width=1),
name="SMA500")])
fig.show()

KO_Data['EMA5'] = KO_Data.Close.ewm(span=5,
adjust=False).mean()

KO_Data['EMA20'] = KO_Data.Close.ewm(span=20,
adjust=False).mean()
KO_Data['EMA50'] = KO_Data.Close.ewm(span=50,
adjust=False).mean()
KO_Data['EMA200'] = KO_Data.Close.ewm(span=200,
adjust=False).mean()
KO_Data['EMA500'] = KO_Data.Close.ewm(span=500,
adjust=False).mean()

fig = go.Figure(data=[go.Ohlc(x=KO_Data['Date'],
open=KO_Data['Open'],
high=KO_Data['High'],
low=KO_Data['Low'],
close=KO_Data['Close'], name =

"OHLC"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA5, line=dict(color='orange', width=1),
name="EMA5"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA20, line=dict(color='green', width=1),
name="EMA20"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA50, line=dict(color='blue', width=1),
name="EMA50"),

go.Scatter(x=KO_Data.Date,

y=KO_Data.SMA200, line=dict(color='violet', width=1),
name="EMA200"),

go.Scatter(x=KO_Data.Date,
y=KO_Data.SMA500, line=dict(color='purple', width=1),
name="EMA500")])
fig.show()

KO_Data.head()
KO_Data.fillna(0)
KO_Data.set_index('Date')

try:
  from finta import TA
  from backtesting import Backtest, Strategy
  from backtesting.lib import crossover
except:
  !pip install finta backtesting
  from finta import TA
  from backtesting import Backtest, Strategy
  from backtesting.lib import crossover

fin_ma = pd.read_csv('/content/Coca-Cola_stock_history (2).csv', parse_dates=True)
print(fin_ma.head())
ohlc=fin_ma
print(TA.SMA(ohlc, 42))
#ohlc.index = ohlc[index].dt.date

# Dictionary of technical indicators
function_dict = {
    'Simple Moving Average': 'SMA',
    'Simple Moving Median': 'SMM',
    'Smoothed Simple Moving Average': 'SSMA',
    'Exponential Moving Average': 'EMA',
    'Double Exponential Moving Average': 'DEMA',
    'Triple Exponential Moving Average': 'TEMA',
    'Triangular Moving Average': 'TRIMA',
    'Triple Exponential Moving Average Oscillator': 'TRIX',
    'Volume Adjusted Moving Average': 'VAMA',
    'Kaufman Efficiency Indicator': 'ER',
    'Kaufmans Adaptive Moving Average': 'KAMA',
    'Zero Lag Exponential Moving Average': 'ZLEMA',
    'Weighted Moving Average': 'WMA',
    'Hull Moving Average': 'HMA',
    'Elastic Volume Moving Average': 'EVWMA',
    'Volume Weighted Average Price': 'VWAP',
    'Smoothed Moving Average': 'SMMA',
    'Fractal Adaptive Moving Average': 'FRAMA',
    'Moving Average Convergence Divergence': 'MACD',
    'Percentage Price Oscillator': 'PPO',
    'Volume-Weighted MACD': 'VW_MACD',
    'Elastic-Volume weighted MACD': 'EV_MACD',
    'Market Momentum': 'MOM',
    'Rate-of-Change': 'ROC',
    'Relative Strength Index': 'RSI',
    'Inverse Fisher Transform RSI': 'IFT_RSI',
    'True Range': 'TR',
    'Average True Range': 'ATR',
    'Stop-and-Reverse': 'SAR',
    'Bollinger Bands': 'BBANDS',
    'Bollinger Bands Width': 'BBWIDTH',
    'Momentum Breakout Bands': 'MOBO',
    'Percent B': 'PERCENT_B',
    'Keltner Channels': 'KC',
    'Donchian Channel': 'DO',
    'Directional Movement Indicator': 'DMI',
    'Average Directional Index': 'ADX',
    'Pivot Points': 'PIVOT',
    'Fibonacci Pivot Points': 'PIVOT_FIB',
    'Stochastic Oscillator Percent K': 'STOCH',
    'Stochastic oscillator Percent D': 'STOCHD',
    'Stochastic RSI': 'STOCHRSI',
    'Williams Percent R': 'WILLIAMS',
    'Ultimate Oscillator': 'UO',
    'Awesome Oscillator': 'AO',
    'Mass Index': 'MI',
    'Know Sure Thing': 'KST',
    'True Strength Index': 'TSI',
    'Typical Price': 'TP',
    'Accumulation-Distribution Line': 'ADL',
    'Chaikin Oscillator': 'CHAIKIN',
    'Money Flow Index': 'MFI',
    'On Balance Volume': 'OBV',
    'Weighter OBV': 'WOBV',
    'Volume Zone Oscillator': 'VZO',
    'Price Zone Oscillator': 'PZO',
    'Elders Force Index': 'EFI',
    'Cummulative Force Index': 'CFI',
    'Bull power and Bear Power': 'EBBP',
    'Ease of Movement': 'EMV',
    'Commodity Channel Index': 'CCI',
    'Coppock Curve': 'COPP',
    'Buy and Sell Pressure': 'BASP',
    'Normalized BASP': 'BASPN',
    'Chande Momentum Oscillator': 'CMO',
    'Chandelier Exit': 'CHANDELIER',
    'Qstick': 'QSTICK',
    'Wave Trend Oscillator': 'WTO',
    'Fisher Transform': 'FISH',
    'Ichimoku Cloud': 'ICHIMOKU',
    'Adaptive Price Zone': 'APZ',
    'Volume Price Trend': 'VPT',
    'Finite Volume Element': 'FVE',
    'Volume Flow Indicator': 'VFI',
    'Moving Standard deviation': 'MSD',
    'Schaff Trend Cycle': 'STC'
}

# Loop through each indicator and plot it
for key, value in function_dict.items():
    try:
        function_name = f"TA.{value}(ohlc).plot(title='{key} for Coca Cola / Coke Stock')"
        print(f"Running: {function_name}")
        result = eval(function_name)
    except Exception as e:
        print(f"⚠️ Error with {key}: {e}")

# Defining DEMA cross strategy
class DemaCross(Strategy):

  def init(self):

    self.ma1 = self.I(TA.DEMA, ohlc, 10)
    self.ma2 = self.I(TA.DEMA, ohlc, 20)

  def next(self):
   if crossover(self.ma1, self.ma2):

      self.buy()
   elif crossover(self.ma2, self.ma1):
      self.sell()

ohlc.head()
print(ohlc.Date)

bt = Backtest(ohlc, DemaCross,

cash=100000, commission=0.015,

exclusive_orders=True)

bt.run()

bt.plot()

data=ohlc

from backtesting import Strategy
from backtesting.lib import crossover
from backtesting.test import SMA

def BBANDS(data, n_lookback, n_std):
  print("""Bollinger bands indicator""")
  hlc3 = (data.High + data.Low + data.Close) / 3
  mean, std = hlc3.rolling(n_lookback).mean(),

  hlc3.rolling(n_lookback).std()
  upper = mean + n_std*std
  lower = mean - n_std*std
  return upper, lower

  close = data.Close.values
  sma10 = SMA(data.Close, 10)
  sma20 = SMA(data.Close, 20)
  sma50 = SMA(data.Close, 50)
  sma100 = SMA(data.Close, 100)
  upper, lower = BBANDS(data, 20, 2)

# Design matrix / independent features:

# Price-derived features
  data['X_SMA10'] = (close - sma10) / close
  data['X_SMA20'] = (close - sma20) / close
  data['X_SMA50'] = (close - sma50) / close
  data['X_SMA100'] = (close - sma100) / close

  data['X_DELTA_SMA10'] = (sma10 - sma20) / close
  data['X_DELTA_SMA20'] = (sma20 - sma50) / close
  data['X_DELTA_SMA50'] = (sma50 - sma100) / close

# Indicator features
  data['X_MOM'] = data.Close.pct_change(periods=2)
  data['X_BB_upper'] = (upper - close) / close
  data['X_BB_lower'] = (lower - close) / close
  data['X_BB_width'] = (upper - lower) / close
#data['X_Sentiment'] =
  ~data.index.to_series().between('2017-09-27', '2017-12-14')

# Some datetime features for good measure
#data['X_day'] = data.index.dayofweek
#data['X_hour'] = data.index.hour

#data = data.apply(pd.to_numeric)
#data = data.dropna().astype(np.float64)
#data.fillna(method="ffill")
#data =data[~data.isin([np.nan, np.inf, -np.inf]).any(1)]

#data.replace([np.inf, -np.inf], 0.0, inplace=True)
#data = data.fillna(data.mean(), inplace=True)
#data = data.dropna().astype(np.float64)

class Sma4Cross(Strategy):
  n1 = 50

  n2 = 100
  n_enter = 20
  n_exit = 10

  def init(self):
    self.sma1 = self.I(SMA, self.data.Close, self.n1)
    self.sma2 = self.I(SMA, self.data.Close, self.n2)
    self.sma_enter = self.I(SMA, self.data.Close,

    self.n_enter)

    self.sma_exit = self.I(SMA, self.data.Close,

    self.n_exit)

  def next(self):

    if not self.position:

# On upwards trend, if price closes above
# "entry" MA, go long

# Here, even though the operands are arrays, this
# works by implicitly comparing the two last values
      if self.sma1 > self.sma2:
        if crossover(self.data.Close, self.sma_enter):
           self.buy()

# On downwards trend, if price closes below
# "entry" MA, go short

      else:
       if crossover(self.sma_enter, self.data.Close):
          self.sell()

# But if we already hold a position and the price
# closes back below (above) "exit" MA, close the position

       else:
          if (self.position.is_long and crossover(self.sma_exit, self.data.Close)
          or
          self.position.is_short and
          crossover(self.data.Close, self.sma_exit)):

            self.position.close()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# !pip install backtesting --quiet
# 
# from backtesting import Backtest, Strategy
# from backtesting.test import GOOG
# from backtesting.lib import crossover
# import numpy as np
# import pandas as pd
# import matplotlib.pyplot as plt
# 
# # --------------------------
# # 1️⃣ Define Strategy Properly
# # --------------------------
# class Sma4Cross(Strategy):
#     n1 = 20
#     n2 = 50
#     n_enter = 25
#     n_exit = 15
# 
#     def init(self):
#         # ✅ Correct: use self.I() to define indicators
#         close = self.data.Close
#         self.sma1 = self.I(lambda x: pd.Series(x).rolling(self.n1).mean(), close)
#         self.sma2 = self.I(lambda x: pd.Series(x).rolling(self.n2).mean(), close)
# 
#     def next(self):
#         # Buy when short SMA crosses above long SMA
#         if crossover(self.sma1, self.sma2):
#             self.buy()
#         # Sell when short SMA crosses below long SMA
#         elif crossover(self.sma2, self.sma1):
#             self.sell()
# 
# # --------------------------
# # 2️⃣ Run Backtest
# # --------------------------
# bt = Backtest(GOOG, Sma4Cross, commission=.002, exclusive_orders=True)
# 
# # --------------------------
# # 3️⃣ Optimize Parameters
# # --------------------------
# stats, heatmap = bt.optimize(
#     n1=range(10, 110, 10),
#     n2=range(20, 210, 20),
#     n_enter=range(15, 35, 5),
#     n_exit=range(10, 25, 5),
#     constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
#     maximize='Equity Final [$]',
#     max_tries=100,  # fewer tries to make it faster
#     random_state=0,
#     return_heatmap=True
# )
# 
# # --------------------------
# # 4️⃣ Print and Plot
# # --------------------------
# print(stats)
# 
# bt.plot()
# 
# # Optional: visualize heatmap
# heatmap_df = pd.DataFrame(heatmap)
# plt.figure(figsize=(8,6))
# plt.imshow(heatmap_df.values, aspect='auto', cmap='viridis')
# plt.colorbar(label='Final Equity ($)')
# plt.title('Parameter Optimization Heatmap')
# plt.xlabel('Combination Index')
# plt.ylabel('Trial')
# plt.show()
#

hm = heatmap.groupby(['n1', 'n2']).mean().unstack()
hm

from backtesting.lib import plot_heatmaps

plot_heatmaps(heatmap, agg='mean')